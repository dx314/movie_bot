// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
)

const deleteMessageData = `-- name: DeleteMessageData :exec
DELETE FROM msg_data
WHERE message_id = ?
`

func (q *Queries) DeleteMessageData(ctx context.Context, messageID int) error {
	_, err := q.db.ExecContext(ctx, deleteMessageData, messageID)
	return err
}

const deleteNZBInfo = `-- name: DeleteNZBInfo :exec
DELETE
FROM nzb_info
WHERE id = ?
`

func (q *Queries) DeleteNZBInfo(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteNZBInfo, id)
	return err
}

const deleteUnselectedOptions = `-- name: DeleteUnselectedOptions :exec
DELETE
FROM nzb_info
WHERE chat_id = ?
  AND selected = FALSE
`

func (q *Queries) DeleteUnselectedOptions(ctx context.Context, chatID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUnselectedOptions, chatID)
	return err
}

const getIncompleteDownloads = `-- name: GetIncompleteDownloads :many
SELECT id, url, name, category, sabnzbd_id, chat_id, message_id, status, last_updated, selected
FROM nzb_info
WHERE selected = TRUE
  AND status NOT IN ('Completed', 'Failed')
`

func (q *Queries) GetIncompleteDownloads(ctx context.Context) ([]NzbInfo, error) {
	rows, err := q.db.QueryContext(ctx, getIncompleteDownloads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NzbInfo
	for rows.Next() {
		var i NzbInfo
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Name,
			&i.Category,
			&i.SabnzbdID,
			&i.ChatID,
			&i.MessageID,
			&i.Status,
			&i.LastUpdated,
			&i.Selected,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageData = `-- name: GetMessageData :one
SELECT message_id, user_id, search, year, category FROM msg_data
WHERE message_id = ?
`

func (q *Queries) GetMessageData(ctx context.Context, messageID int) (MsgDatum, error) {
	row := q.db.QueryRowContext(ctx, getMessageData, messageID)
	var i MsgDatum
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.Search,
		&i.Year,
		&i.Category,
	)
	return i, err
}

const getNZBInfo = `-- name: GetNZBInfo :one
SELECT id, url, name, category, sabnzbd_id, chat_id, message_id, status, last_updated, selected
FROM nzb_info
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetNZBInfo(ctx context.Context, id string) (NzbInfo, error) {
	row := q.db.QueryRowContext(ctx, getNZBInfo, id)
	var i NzbInfo
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Name,
		&i.Category,
		&i.SabnzbdID,
		&i.ChatID,
		&i.MessageID,
		&i.Status,
		&i.LastUpdated,
		&i.Selected,
	)
	return i, err
}

const insertMessageData = `-- name: InsertMessageData :one
INSERT INTO msg_data (message_id, user_id, category, year, search) VALUES (?, ?, ?, ?, ?) RETURNING message_id, user_id, search, year, category
`

type InsertMessageDataParams struct {
	MessageID int    `json:"message_id"`
	UserID    int64  `json:"user_id"`
	Category  string `json:"category"`
	Year      string `json:"year"`
	Search    string `json:"search"`
}

func (q *Queries) InsertMessageData(ctx context.Context, arg InsertMessageDataParams) (MsgDatum, error) {
	row := q.db.QueryRowContext(ctx, insertMessageData,
		arg.MessageID,
		arg.UserID,
		arg.Category,
		arg.Year,
		arg.Search,
	)
	var i MsgDatum
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.Search,
		&i.Year,
		&i.Category,
	)
	return i, err
}

const upsertNZBInfo = `-- name: UpsertNZBInfo :exec
INSERT INTO nzb_info (id, url, name, category, sabnzbd_id, chat_id, message_id, status, last_updated, selected)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id)
    DO UPDATE
    SET url          = excluded.url,
        name         = excluded.name,
        category     = excluded.category,
        sabnzbd_id   = excluded.sabnzbd_id,
        chat_id      = excluded.chat_id,
        message_id   = excluded.message_id,
        status       = excluded.status,
        last_updated = excluded.last_updated,
        selected     = excluded.selected
`

type UpsertNZBInfoParams struct {
	ID          string `json:"id"`
	Url         string `json:"url"`
	Name        string `json:"name"`
	Category    string `json:"category"`
	SabnzbdID   string `json:"sabnzbd_id"`
	ChatID      int64  `json:"chat_id"`
	MessageID   int    `json:"message_id"`
	Status      string `json:"status"`
	LastUpdated int64  `json:"last_updated"`
	Selected    int    `json:"selected"`
}

func (q *Queries) UpsertNZBInfo(ctx context.Context, arg UpsertNZBInfoParams) error {
	_, err := q.db.ExecContext(ctx, upsertNZBInfo,
		arg.ID,
		arg.Url,
		arg.Name,
		arg.Category,
		arg.SabnzbdID,
		arg.ChatID,
		arg.MessageID,
		arg.Status,
		arg.LastUpdated,
		arg.Selected,
	)
	return err
}
